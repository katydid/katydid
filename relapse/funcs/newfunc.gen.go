// Code generated by funcs-gen. DO NOT EDIT.
package funcs

//NewDouble dynamically creates and asserts the returning function is of type Double.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewDouble(values ...interface{}) (Double, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Double), nil
}

//NewInt dynamically creates and asserts the returning function is of type Int.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewInt(values ...interface{}) (Int, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Int), nil
}

//NewUint dynamically creates and asserts the returning function is of type Uint.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewUint(values ...interface{}) (Uint, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Uint), nil
}

//NewBool dynamically creates and asserts the returning function is of type Bool.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewBool(values ...interface{}) (Bool, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bool), nil
}

//NewString dynamically creates and asserts the returning function is of type String.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewString(values ...interface{}) (String, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(String), nil
}

//NewBytes dynamically creates and asserts the returning function is of type Bytes.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewBytes(values ...interface{}) (Bytes, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bytes), nil
}

//NewDoubles dynamically creates and asserts the returning function is of type Doubles.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewDoubles(values ...interface{}) (Doubles, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Doubles), nil
}

//NewInts dynamically creates and asserts the returning function is of type Ints.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewInts(values ...interface{}) (Ints, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Ints), nil
}

//NewUints dynamically creates and asserts the returning function is of type Uints.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewUints(values ...interface{}) (Uints, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Uints), nil
}

//NewBools dynamically creates and asserts the returning function is of type Bools.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewBools(values ...interface{}) (Bools, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Bools), nil
}

//NewStrings dynamically creates and asserts the returning function is of type Strings.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewStrings(values ...interface{}) (Strings, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(Strings), nil
}

//NewListOfBytes dynamically creates and asserts the returning function is of type ListOfBytes.
//This function is used by the compose library to compile functions together.
func (f *Maker) NewListOfBytes(values ...interface{}) (ListOfBytes, error) {
	v, err := f.New(values...)
	if err != nil {
		return nil, err
	}
	return v.(ListOfBytes), nil
}
